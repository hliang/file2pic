<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary File ‚Üî Image Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 800px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
        }

        .upload-area:hover {
            background: #f8f9ff;
            border-color: #764ba2;
        }

        .upload-area.dragover {
            background: #f0f4ff;
            border-color: #764ba2;
        }

        input[type="file"] {
            display: none;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.2s;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .preview {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            display: none;
        }

        .preview.show {
            display: block;
        }

        .preview img {
            max-width: 100%;
            border-radius: 8px;
            margin-top: 10px;
        }

        .file-info {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 13px;
        }

        .progress {
            margin-top: 15px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #667eea;
            width: 0%;
            transition: width 0.3s;
        }

        .format-options {
    </style>
</head>
<body>
    <div class="container">
        <h1>üñºÔ∏è Binary File ‚Üî Image Converter</h1>
        <p class="subtitle">Convert any file to an image (PNG/JPG) and back - all in your browser!</p>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('encode')">Encode File ‚Üí Image</button>
            <button class="tab" onclick="switchTab('decode')">Decode Image ‚Üí File</button>
        </div>

        <!-- Encode Tab -->
        <div id="encode-tab" class="tab-content active">
            <div class="upload-area" id="encode-upload" onclick="document.getElementById('encode-file').click()">
                <div class="upload-icon">üìÅ</div>
                <div>Click to select a file or drag & drop</div>
                <div style="font-size: 12px; color: #999; margin-top: 5px;">Any file type supported</div>
            </div>
            <input type="file" id="encode-file" onchange="handleEncodeFile(this.files[0])">

            <div class="preview" id="encode-preview">
                <strong>Generated Image:</strong>
                <img id="encode-image" alt="Encoded image">
                <div class="file-info" id="encode-info"></div>
                <button class="btn" onclick="downloadImage()">üíæ Download Image</button>
            </div>

            <div class="progress" id="encode-progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="encode-progress-fill"></div>
                </div>
            </div>
        </div>

        <!-- Decode Tab -->
        <div id="decode-tab" class="tab-content">
            <div class="upload-area" id="decode-upload" onclick="document.getElementById('decode-file').click()">
                <div class="upload-icon">üñºÔ∏è</div>
                <div>Click to select an encoded PNG image or drag & drop</div>
                <div style="font-size: 12px; color: #999; margin-top: 5px;">PNG only (JPEG not supported)</div>
            </div>
            <input type="file" id="decode-file" accept="image/png" onchange="handleDecodeFile(this.files[0])">

            <div class="preview" id="decode-preview">
                <button class="btn" onclick="downloadDecodedFile()">üíæ Download Original File</button>
                <div><strong>File Information:</strong></div>
                <div class="file-info" id="decode-info"></div>
                <div id="decode-content-preview"></div>
            </div>

            <div class="progress" id="decode-progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="decode-progress-fill"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let encodedImageData = null;
        let decodedFileData = null;
        let originalFileName = '';
        let originalFileType = '';

        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tab + '-tab').classList.add('active');
        }

        // Drag and drop handlers
        ['encode-upload', 'decode-upload'].forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('dragover', (e) => {
                e.preventDefault();
                el.classList.add('dragover');
            });
            el.addEventListener('dragleave', () => el.classList.remove('dragover'));
            el.addEventListener('drop', (e) => {
                e.preventDefault();
                el.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (id === 'encode-upload') handleEncodeFile(file);
                else handleDecodeFile(file);
            });
        });

        async function handleEncodeFile(file) {
            if (!file) return;

            document.getElementById('encode-progress').style.display = 'block';
            document.getElementById('encode-progress-fill').style.width = '30%';

            originalFileName = file.name;
            originalFileType = file.type || 'application/octet-stream';

            const reader = new FileReader();
            reader.onload = async (e) => {
                const arrayBuffer = e.target.result;
                const bytes = new Uint8Array(arrayBuffer);

                // Create metadata header
                const metadata = {
                    name: originalFileName,
                    type: originalFileType,
                    size: bytes.length
                };
                const metadataStr = JSON.stringify(metadata);
                const metadataBytes = new TextEncoder().encode(metadataStr);
                const metadataLength = metadataBytes.length;

                // Calculate image dimensions
                const headerSize = 4 + metadataLength; // 4 bytes for metadata length + metadata
                const totalBytes = headerSize + bytes.length;
                const pixelsNeeded = Math.ceil(totalBytes / 3); // 3 bytes per pixel (RGB)
                const dimension = Math.ceil(Math.sqrt(pixelsNeeded));
                
                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.width = dimension;
                canvas.height = dimension;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(dimension, dimension);
                
                // Write metadata length (4 bytes)
                const lengthBytes = new Uint8Array(4);
                new DataView(lengthBytes.buffer).setUint32(0, metadataLength, false);
                
                // Combine all data
                const allData = new Uint8Array(totalBytes);
                allData.set(lengthBytes, 0);
                allData.set(metadataBytes, 4);
                allData.set(bytes, headerSize);
                
                // Write to image (skip alpha channel - only write to RGB)
                let dataIndex = 0;
                for (let i = 0; i < imageData.data.length; i += 4) {
                    if (dataIndex < allData.length) {
                        imageData.data[i] = allData[dataIndex++]; // R
                    } else {
                        imageData.data[i] = 255; // R
                    }
                    if (dataIndex < allData.length) {
                        imageData.data[i + 1] = allData[dataIndex++]; // G
                    } else {
                        imageData.data[i + 1] = 255; // G
                    }
                    if (dataIndex < allData.length) {
                        imageData.data[i + 2] = allData[dataIndex++]; // B
                    } else {
                        imageData.data[i + 2] = 255; // B
                    }
                    imageData.data[i + 3] = 255; // A (always 255)
                }
                
                ctx.putImageData(imageData, 0, 0);

                document.getElementById('encode-progress-fill').style.width = '70%';

                // Convert to PNG
                encodedImageData = canvas.toDataURL('image/png');
                
                document.getElementById('encode-image').src = encodedImageData;
                document.getElementById('encode-info').innerHTML = `
                    Original File: ${originalFileName}<br>
                    Original Size: ${formatBytes(bytes.length)}<br>
                    Image Dimensions: ${dimension}x${dimension}
                `;
                
                document.getElementById('encode-preview').classList.add('show');
                document.getElementById('encode-progress-fill').style.width = '100%';
                setTimeout(() => {
                    document.getElementById('encode-progress').style.display = 'none';
                    document.getElementById('encode-progress-fill').style.width = '0%';
                }, 500);
            };
            reader.readAsArrayBuffer(file);
        }

        async function handleDecodeFile(file) {
            if (!file) return;

            document.getElementById('decode-progress').style.display = 'block';
            document.getElementById('decode-progress-fill').style.width = '30%';

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, img.width, img.height);
                    
                    document.getElementById('decode-progress-fill').style.width = '60%';

                    // Read metadata length from RGB channels only
                    const metadataLengthBytes = new Uint8Array(4);
                    metadataLengthBytes[0] = imageData.data[0]; // R of pixel 0
                    metadataLengthBytes[1] = imageData.data[1]; // G of pixel 0
                    metadataLengthBytes[2] = imageData.data[2]; // B of pixel 0
                    metadataLengthBytes[3] = imageData.data[4]; // R of pixel 1
                    const metadataLength = new DataView(metadataLengthBytes.buffer).getUint32(0, false);
                    
                    // Validate metadata length
                    if (metadataLength > 10000 || metadataLength < 10) {
                        alert('Error: This does not appear to be a valid encoded image. Metadata length: ' + metadataLength);
                        document.getElementById('decode-progress').style.display = 'none';
                        return;
                    }
                    
                    // Read metadata from RGB channels
                    const metadataBytes = new Uint8Array(metadataLength);
                    let byteIndex = 0;
                    let pixelDataIndex = 4; // Start after the 4 length bytes (which used first pixel's RGB and second pixel's R)
                    
                    while (byteIndex < metadataLength) {
                        const pixelOffset = Math.floor(pixelDataIndex / 3) * 4 + (pixelDataIndex % 3);
                        metadataBytes[byteIndex] = imageData.data[pixelOffset];
                        byteIndex++;
                        pixelDataIndex++;
                    }
                    
                    const metadataStr = new TextDecoder().decode(metadataBytes);
                    let metadata;
                    try {
                        metadata = JSON.parse(metadataStr);
                    } catch (e) {
                        alert('Error: Could not decode image metadata. Metadata string: ' + metadataStr.substring(0, 100));
                        document.getElementById('decode-progress').style.display = 'none';
                        return;
                    }
                    
                    // Read file data
                    const headerSize = 4 + metadataLength;
                    const fileDataArray = new Uint8Array(metadata.size);
                    
                    // Copy pixel data (RGB only, skip alpha channel)
                    let dataIdx = 0;
                    let pixelIdx = headerSize;
                    while (dataIdx < metadata.size) {
                        const pixelOffset = Math.floor(pixelIdx / 3) * 4 + (pixelIdx % 3);
                        fileDataArray[dataIdx] = imageData.data[pixelOffset];
                        dataIdx++;
                        pixelIdx++;
                    }
                    
                    decodedFileData = new Blob([fileDataArray], { type: metadata.type });
                    originalFileName = metadata.name;
                    
                    document.getElementById('decode-info').innerHTML = `
                        File Name: ${metadata.name}<br>
                        File Type: ${metadata.type}<br>
                        File Size: ${formatBytes(metadata.size)}<br>
                        Status: ‚úÖ Successfully decoded
                    `;
                    
                    // Preview content if possible
                    displayDecodedContent(decodedFileData, metadata.type);
                    
                    document.getElementById('decode-preview').classList.add('show');
                    document.getElementById('decode-progress-fill').style.width = '100%';
                    setTimeout(() => {
                        document.getElementById('decode-progress').style.display = 'none';
                        document.getElementById('decode-progress-fill').style.width = '0%';
                    }, 500);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = originalFileName + '.png';
            link.href = encodedImageData;
            link.click();
        }

        function downloadDecodedFile() {
            const link = document.createElement('a');
            link.download = originalFileName;
            link.href = URL.createObjectURL(decodedFileData);
            link.click();
        }

        function displayDecodedContent(blob, mimeType) {
            const previewDiv = document.getElementById('decode-content-preview');
            previewDiv.innerHTML = '';

            // Check if it's an image
            if (mimeType.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = URL.createObjectURL(blob);
                img.style.maxWidth = '100%';
                previewDiv.innerHTML = '<div><strong>Preview:</strong></div>';
                previewDiv.appendChild(img);
            }
            // Check if it's text
            else if (mimeType.startsWith('text/') || 
                     mimeType === 'application/json' ||
                     mimeType === 'application/javascript' ||
                     mimeType === 'application/xml') {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    const pre = document.createElement('pre');
                    // Limit preview to first 1000 characters
                    pre.textContent = text.length > 1000 ? text.substring(0, 1000) + '\n\n... (truncated)' : text;
                    previewDiv.innerHTML = '<div><strong>Preview:</strong></div>';
                    previewDiv.appendChild(pre);
                };
                reader.readAsText(blob);
            }
            // Check if it's a PDF
            else if (mimeType === 'application/pdf') {
                const iframe = document.createElement('iframe');
                iframe.src = URL.createObjectURL(blob);
                iframe.style.width = '100%';
                iframe.style.height = '400px';
                iframe.style.border = 'none';
                previewDiv.innerHTML = '<div><strong>Preview:</strong></div>';
                previewDiv.appendChild(iframe);
            }
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
    </script>
</body>
</html>
